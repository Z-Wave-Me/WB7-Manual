<!DOCTYPE HTML>
<html>
   <head>
      <meta charset="utf-8">
      <title>Z-Wave.Me Multi-Protocol Controller</title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
<!--      <link rel="stylesheet" href="css/zniffer.css">-->
      <script src="js/index.js" defer></script>
      <link rel="stylesheet" href="css/style.css">
<!--      <script src="js/zniffer.js" defer></script>-->
   </head>
   <body>
      <aside class="side-menu open">
         <nav>
            <div class="side-menu-header">
               <div class="close" onclick="toggleMenu()"></div>
            </div>
            <div>
               <img src="https://z-wave.me/files/manual/zniffer/pics/Z-Wave-Me.png" alt="">
            </div>
            <h3>Z-Wave.Me Multi-Protocol Controller Manual</h3>
            <ul class="ChildLinks">
               <li><a href="#ProductDescription">Product description</a></li>
               <li><a href="#WhatIsZ-Wave">What is Z-Wave™ and Long Range?</a></li>
               <li><a href="#KNXZ-WaveZigbee">KNX, Z-Wave, Zigbee</a></li>
               <li><a href="#InstallationGuidelines">Installation Guidelines</a></li>
               <li><a href="#WiFiAccessPoint">Wi-Fi Access Point</a></li>
               <li><a href="#OperatingTheDevice">Operating The Device</a>
                  <ul>
                     <li><a href="#SmartHomeUI">SmartHome UI</a></li>
                     <li><a href="#ExpertUI">Expert UI</a></li>
                     <li><a href="#WirenBoardUI">WirenBoard UI</a></li>
                  </ul>
               </li>
               <li><a href="#MobileApp">Mobile App</a></li>
               <li><a href="#ConnectingDevice">Connecting devices</a>
                  <ul>
                     <!--<li><a href="#ConnectingZWaveDevice">Connecting a Z-Wave device</a></li>-->
                     <!--<li><a href="#ConnectingZigbeeDevice">Connecting a Zigbee device</a></li>-->
                     <!--<li><a href="#ConnectingKNXDevice">Connecting a KNX device</a></li>-->
                     <li><a href="#ConnectingModbusDevice">Connecting a Modbus device</a></li>
                     <!--<li><a href="#ConnectingLoxone">Connecting to Loxone</a></li>-->
                  </ul>
               </li>
               <li><a href="#TechnicalDetails">Technical Details</a></li>
            </ul>
         </nav>
      </aside>
      <header>
         <div class="wrapper">
            <div class="content">
               <div class="menu">
                  <div class="hide-when-open hamburger" onclick="toggleMenu()"></div>
               </div>
            </div>
         </div>
      </header>
      <div class="wrapper wrapper-helper">
         <div class="content">
            <h1 id="ProductDescription">Product description</h1>
            <p>Models: ZMEEWB7-ZW-ZB and ZMEEWB7-ZW-ZB-KNX</p>
            <center><img src="pics/WB7.png" width="80%"></center>
            <p>Z-Wave.Me Multi-Protocol Controller is a modular programmable controller for automation of apartments, houses and offices. The controller can work with wired and wireless sensors and actuators. Support for the Z-Wave™ and Zigbee wireless home automation protocols is provided by a special expansion board and Z-Way software by the Z-Wave.Me. The controller has passed Z-Wave certification, which guarantees compatibility with all certified Z-Wave devices.</p>
            <p>The main advantages of the controller:</p>
            <ul>
               <li>open HTTP/JS/C API for interacting with devices</li>
               <li>integration with iRidi visualization systems</li>
               <li>mobile apps for iOS, Android</li>
               <li>integration with other smart home systems, like HomeAssistant, OpenHAB, NodeRed, etc</li>
               <li>voice assistants: Google Assistant, Amazon's Alexa, Apple's Siri</li>
               <li>scripts allow you to implement flexible house management rules, create schedules, run scenarios</li>
               <li>full information about the capabilities of devices, about routes in the network, convenient diagnostic tools for the Z-Wave network</li>
               <li>secure remote access for management from anywhere in the world without using a static IP</li>
            </ul>
            <p>Z-Wave.Me Multi-Protocol controller contains the 7th generation Z-Wave chip, which provides the following modern features:</p>
            <ul>
               <li>direct line of sight transmission distance of 1.6 km in Z-Wave Long Range mode</li>
               <li>Smart Start for trouble-free deployment of a big installation</li>
               <li>high data transfer rate of 100 kb/sec allows you to transfer data faster, it saves battery power</li>
               <li>the Z-Wave Plus™ v2 certification standard guarantees compatibility of devices from different manufacturers</li>
               <li>mandatory for all devices, S2 encryption protects against listening to the radio</li>
            </ul>
            <p>Z-Wave.Me Multi-Protocol Controller also contains an EFR32MG21 chip, which provides communication with Zigbee and Thread.</p>

            <h1 id="WhatIsZ-Wave">What is Z-Wave™ and Long Range?</h1>
            <p>The Z-Wave protocol is an open, interoperable, sub-GHz wireless communications technology designed specifically for control, monitoring and status reading applications in residential and light commercial environments. Z-Wave has two operating modes Z-Wave MESH which is a very reliable sub-GHz MESH and Long Range (US only) which operates in a STAR topology offering over a mile range.</p>
            <p>This product can be operated in any Z-Wave network with other Z-Wave certified devices from other manufacturers.</p>
            <p><b>Note:</b> To add in Z-Wave Long Range mode, you can only use Smart Start.</p>

            <h1 id="KNXZ-WaveZigbee">KNX, Z-Wave, Zigbee</h1>
            <p>The controller supports simultaneous operation in wireless Z-Wave and Zigbee networks and wired KNX network. This allows you to combine different automation technologies and benefit from a large number of different devices available for your smart home project.</p>
            <p><b>KNX</b> is designed for installation in large houses due to the reliability of the wired connection.</p>
            <p><b>Z-Wave</b> allows retrofit installations as well as extending KNX installations with high-quality and functional devices.</p>
            <p><b>Zigbee</b> opens the door to a broad range of inexpensive devices.</p>

            <center><img src="pics/logos.png" width="100%"></center>

            <h1 id="InstallationGuidelines">Installation Guidelines</h1>
            <ul>
               <li>Connect the ethernet cable to the connector Ethernet 1</li>
               <li>Connect the 9–48V power supply to the terminals GND and V+</li>
               <li>Turn on the switch on the lid</li>
               <li>Wait for the controller to load, the indicator will flash green</li>
               <li>Go to <a href="https://find.z-wave.me">https://find.z-wave.me</a> to find out the IP address of the controller in your local network</li>
               <li>Also, you can view the IP address of the controller on the router</li>
               <li>In local network go to the controller address http://IP:8083</li>
               <li>When you first log in, set the administrator password and email</li>
               <li>It is recommended to change the SSH access credentials</li>
               <li>By default login: root, password: wirenboard. To change it connect via SSH, enter the passwd command and enter the new password twice</li>
            </ul>

            <div>
               <img src="pics/find-en.png" width="45%" style="float: left; padding: 5px;">
               <img src="pics/first-en.png" width="45%" style="padding: 5px;">
            </div>

            <h1 id="WiFiAccessPoint">Wi-Fi Access Point</h1>
            <p>You can connect to the controller via Wi-Fi. Use the following access details:</p>
            <ul>
               <li>SSID: Z-Wave.Me-XXXXXXXX</li>
               <li>Password: Z-Wave.Me</li>
            </ul>
            <p><b>Attention! For security reasons, change the wi-fi password!</b></p>

            <h1 id="OperatingTheDevice">Operating The Device</h1>
            <h3 id="SmartHomeUI">SmartHome UI</h3>
            <center><img src="pics/smarthome-en.png" width="100%"></center>
            <p><b>SmartHome UI</b> is the main web interface for working with Z-Wave devices. SmartHome UI is used to manage devices and configure home automation scenarios.</p>

            <h3 id="ExpertUI">Expert UI</h3>
            <center><img src="pics/expert-en.png" width="100%"></center>
            <p><b>Expert UI</b> is designed for advanced setup of Z-Wave devices. Allows you to get complete information about the Z-Wave network, to diagnose and optimize.</p>

            <h3 id="WirenBoardUI">WirenBoard UI</h3>
            <center><img src="pics/wb-en.png" width="100%"></center>
            <p><b>WirenBoard UI</b> is used to work with wired peripherals, manage system settings and configure hardware inputs/outputs.</p>

            <h1 id="MobileApp">Z-Wave.Me Mobile App</h1>
            <div>
               <img src="pics/IMG_3963.PNG" width="30%" style="float: left; padding: 5px;">
               <img src="pics/IMG_3964.PNG" width="30%" style="float: left; padding: 5px;">
               <img src="pics/IMG_3965.PNG" width="30%" style="padding: 5px;">
            </div>

            <table border="1" class="wikitable" style="text-align:left;">
               <tbody>
                  <tr>
                     <th colspan="2">
                        <b>Download the Z-Wave.Me mobile app</b>
                     </th>
                  </td>
                  <tr>
                     <td>
                        <a href="https://apps.apple.com/app/id1513858668">
                           <img src="pics/AppStore.png" style="float: left; padding: 5px; width: 10em;">
                        </a>
                     <td>
                        <a href="https://apps.apple.com/app/id1513858668">
                           Z-Wave.Me mobile app for iOS
                        </a>
                     </td>
                  </tr>
                  <tr>
                     <td>
                        <a href="https://play.google.com/store/apps/details?id=me.zwave.zway">
                           <img src="pics/GooglePlay.png" style="float: left; padding: 5px; width: 10em;">
                        </a>
                     </td>
                     <td>
                        <a href="https://play.google.com/store/apps/details?id=me.zwave.zway">
                           Z-Wave.Me mobile app for Android
                        </a>
                     </td>
                  </tr>
               </tbody>
            </table>

            <h1 id="ConnectingDevice">Connecting devices</h2>
            
            <h2 id="ConnectingModbusDevice">Connecting a Modbus device</h2>
            <p>Configuration of Modbus devices is performed in the <a href="#WirenBoardUI">WirenBoard UI</a> on page Settings → Configs → Serial Device Driver Configuration.</p>
            <p>To connect a Modbus device to the controller using Modbus RTU or Modbus TCP, a template is required. Many Modbus devices already has a template. Check the list of existing templates.</p>
            <center><img src="pics/wb-mqtt-serial.png" width="80%"></center>
            
            <h3>Creating a template</h3>
            <p>There are two ways to tell the wb-mqtt-serial driver, which works with Modbus devices in the controller:</p>
            <ul>
               <li>Add registers of your device directly in the controller web interface. This method is convenient for a quick test or if you need to connect such a device only once.</li>
               <li>Create a template that describes device registers, their type and other parameters. This method is convenient for scaling: you simply copy the template to another controller and the device appears in the templates list.</p>
            </ul>

            <h3>Manually adding register in the UI</h3>
            <p>To add registers of your device directly in the controller web interface, select the <i>Custom Modbus device</i> template and add channels as show on the picture below. Set the type for each channel, map it to a register and define the mapping formula. You can add more parameters by pressing the <i>Parameter</i> button. Read below about creating templates to understand better the meaning of each value.</p>
            <center><img src="pics/wb-mqtt-serial-custom.png" width="60%"></center>
            
            <h3>Creating a template</h3>
            <p>Here we'll look at creating a simple template. A simplified device template looks like this:</p>
            <pre>
            <code lang="json">
{
     "device_type": "my-relay", // device type - unique identifier
     "title": "My Relay", // display title
     "group": "g-relay", // group in which the template will be displayed, see below
     "device": {
         "name": "MY-RELAY", // device name, used in MQTT and in device ID in Z-Way
         "id": "my-relay",
         "groups": [ ], // groups of parameters and channels
         "channels": [ ], // channels, available in scripts and on the Devices tab
         "parameters": [ ], // parameters, can be changed in the device settings
         "translations": { } // translations
     }
}
            </code>
            </pre>

            <p><code>group</code> &mdash; Group of devices in the drop-down list in the serial port settings in the controller web interface. If not specified, the device will be displayed at the bottom of the list.</p>
            <ul>
               <li>g-adapter - protocol adapters</li>
               <li>g-climate-sensor - climate sensors</li>
               <li>g-level - level sensors</li>
               <li>g-dimmer - dimmers</li>
               <li>g-air-conditioning - air conditioners</li>
               <li>g-climate-control - ventilation and climate controllers</li>
               <li>g-refrigeration - refrigeration controllers</li>
               <li>g-io - input/output modules</li>
               <li>g-relay - relay modules</li>
               <li>g-curtain - motors for curtains / electric curtain rods</li>
               <li>g-control-panel - control panels</li>
               <li>g-water-meter - water meters</li>
               <li>g-heat-meter - heat meters</li>
               <li>g-power-meter - electricity meters</li>
               <li>g-thermostat - thermostats</li>
               <li>g-motor-control - motor control (frequency converters)</li>
               <li>g-custom - other devices</li>
            </ul>

            <p>Let's say we have a single-channel Modbus relay with a register table shown below.</p>
            <table border="1" class="wikitable" style="text-align:left">
               <tbody>
                  <tr>
                     <th>Address</th>
                     <th>Type</th>
                     <th>Title</th>
                     <th>Purpose</th>
                  </tr>
                  <tr>
                     <td>0</td>
                     <td>Discrete Input</td>
                     <td>Input 1</td>
                     <td>Device input status</td>
                  </tr>
                  <tr>
                     <td>1</td>
                     <td>Input Register</td>
                     <td>Input 1 Counter</td>
                     <td>Input counter value</td>
                  </tr>
                  <tr>
                     <td>3</td>
                     <td>Coil</td>
                     <td>Relay 1</td>
                     <td>Output status and control</td>
                  </tr>
                  <tr>
                     <td>10</td>
                     <td>Holding</td>
                     <td>Input Mode</td>
                     <td>Selecting the mode of interaction between inputs and outputs</td>
                  </tr>
               </tbody>
            </table>

            <p>In this case, the template will look like this:</p>
            <pre>
            <code lang="json">
{
     "device_type": "my-relay",
     "title": "My Relay",
     "group": "g-relay",
     "device": {
         "name": "MY-RELAY",
         "id": "my-relay",
         "groups": [
             {
                 "title": "Channels",
                 "id": "channels",
                 "order": 0
             },
             {
                 "title": "Settings",
                 "id": "settings",
                 "order": 1
             }
         ],
         "channels": [
             {
                 "name": "Input 1",
                 "reg_type": "discrete",
                 "address": 1,
                 "type": "switch",
                 "group": "channels"
             },
             {
                 "name": "Input 1 Counter",
                 "reg_type": "input",
                 "address": 2,
                 "type": "value",
                 "group": "channels"
             },
             {
                 "name": "Relay 1",
                 "reg_type": "coil",
                 "address": 3,
                 "type": "switch",
                 "group": "channels"
             }
         ],
         "parameters": [
             {
                 "id": "input1",
                 "title": "Input Mode",
                 "reg_type": "input",
                 "address": 10,
                 "format": "s8",
                 "enum": [
                     1,
                     2
                 ],
                 "enum_titles": [
                     "Switch Relay"
                     "Not used"
                 ],
                 "default": 1
             }
         ],
         "translations": {
             "de": {
                 "Channels": "Kanäle",
                 "Settings": "Einstellungen",
                 "Input 1": "Eingang 1",
                 "Input 1 Counter": "Zähler von Eingang 1",
                 "Relay 1": "Relais 1",
                 "Input Mode": "Eingabemodus"
             }
         }
     }
}
            </code>
            </pre>

            <h3>Loading template to controller</h3>
            <p>When the template is ready, it needs to be loaded onto the controller:</p>
            <ul>
               <li>Save the template to a file, for example, <code>my-relay.json</code> and upload it to the controller in the folder <code>/etc/wb-mqtt-serial.conf.d/templates</code> using SSH copy.</li>
               <li>
                  Check the template for syntax errors with the command:
                  <pre><code lang="bash">
# wb-mqtt-serial -g
<3>ERROR: [serial config] Failed to parse /etc/wb-mqtt-serial.conf.d/templates/my-relay.json
Failed to parse JSON /etc/wb-mqtt-serial.conf.d/templates/my-best-template.json:* Line 12, Column 5
   Missing ',' or '}' in object declaration
                  </code></pre>
                  in the example in the template ''my-best-template.json'' on line 12, character 5 is expected <code>,</code> or <code>}</code>, but something else is found.
               </li>
               <li>If everything is fine with the template, then go to the driver settings on the page Settings → Configs → Serial Device Driver Configuration and select your template.</li>
            </ul>

            <h3>Query optimization by the driver</h3>
            <p>The Modbus RTU standard provides a mandatory silence interval of 3.5 characters between data frames (a character means a package consisting of a start bit, data bits, parity bit and stop bits).</p>

            <p>To speed up the polling of devices, the driver respects this interval only before the first request to the next device in the polling cycle (the ''frame_timeout_ms' parameter in device templates).</p>

            <p>Therefore, in order to comply with the requirements of the Modbus-RTU protocol, it is necessary to set the <code>guard_interval_us</code> parameter. This parameter specifies the delay before each request is written to the port.</p>

            <p>The required value is calculated using the formula: <code>guard_interval_us = (3.5*11*106)/(rate in bit/s).</code></p>

            <p>For example, for a speed of 9600 bps <code>guard_interval_us = (3.5*11*106)/9600 = 4000 µs</code>. If there are problems connecting a device, this value can be increased (for example, up to 100 000 μs).</p>

            <h3>Possible problems with devices</h3>

            <p>With some devices, a fairly common situation is when you have made a template, the communication works, but errors appear in the logs, and the device channels in the controller’s web interface are colored red.</p>

            <p>The main reason for this is that the device processes requests from our driver too slowly. To begin with, we recommend connecting such devices to a separate bus so that they do not slow down the operation of normal devices, and then use the recommendations below.</p>

            <p>To fix it, try increasing the <code>guard_interval_us</code> parameter up to thousands of units, for example, 5000. If the operation stabilizes, slowly reduce this value until errors appear again. The previous value when everything worked well will be your value in the template.</p>

            <p>There is also a parameter <code>response_timeout_ms</code>, the maximum device response time in milliseconds, by default 500 ms. You can also experiment carefully with it.</p>

            <p>Do not unnecessarily set huge values in these parameters, this will slow down the polling of devices on the port where the problematic device is connected.</p>

            <p>Both parameters are written to the device section of the template:</p>

            <pre>
            <code lang="json">
"device": {
     "name": "BAC-6000ELNW",
     "id": "bac-6000elnw",
     "response_timeout_ms": 100,
     "guard_interval_us": 5000,
...
}
            </code>
            </pre>

            <h3>Different registers for reading status and control</h3>
            <p>Sometimes devices allows reading from one register and writing to another one. To ensure that the driver works with such devices without errors, there is the <code>write_address</code> parameter.</p>

            <p>Let's say our device has a write-only register:</p>

            <table border="1" class="wikitable" style="text-align:left">
               <tbody>
                  <tr>
                     <th>Address</th>
                     <th>Type</th>
                     <th>Title</th>
                     <th>Purpose</th>
                  </tr>
                  <tr>
                     <td>20</td>
                     <td>Coil</td>
                     <td>Relay 1 Switch</td>
                     <td>Output control, write only</td>
                  </tr>
               </tbody>
            </table>

            <p>In this case, the channel should be described as follows:</p>

            <pre>
            <code lang="json">
{
     "name": "Relay 1 Switch",
     "write_address": "20",
     "reg_type": "coil",
     "type": "pushbutton",
     "format": "u16",
     "group": "channels",
     "on_value": 1 // defines what to write to the register when pressed
}
            </code>
            </pre>

            <p>Let's say that in our device a command is written to one register and read from another. This method can only be used if both registers are of the same type. If the types are different, create two different channels: for reading and for writing.<p>

            <table border="1" class="wikitable" style="text-align:left">
               <tbody>
                  <tr>
                     <th>Address</th>
                     <th>Type</th>
                     <th>Title</th>
                     <th>Purpose</th>
                  </tr>
                  <tr>
                     <td>20</td>
                     <td>Coil</td>
                     <td>Relay 1 Switch</td>
                     <td>Output control, write-only</td>
                  </tr>
                  <tr>
                     <td>21</td>
                     <td>Coil</td>
                     <td>Relay 1 State</td>
                     <td>Output status, read-only</td>
                  </tr>
               </tbody>
            </table>

            <p>In this case, the channel should be described as follows: we will have one parameter in the controller, but when exchanging data, writing will be done from one register, and reading from another:</p>

            <pre>
            <code lang="json">
{
     "name": "Relay 1",
     "write_address": "20", // address where we write commands
     "address": "21", // address at which we read the status
     "reg_type": "coil",
     "type": "switch",
     "format": "u16",
     "group": "channels"
}
            </code>
            </pre>

            <h3>Arbitrary values in registers with binary logic</h3>
            <p>Sometimes it happens that, according to the meaning of the register, it should be represented in the web interface by an ON/OFF switch, but its valid values are not 1/0. In this case, you define a regular channel with type <code>switch</code> and specify the values <code>on_value</code> and <code>off_value</code>, for example:</p>

            <pre>
            <code lang="json">
{
   "name": "Status",
   "reg_type": "holding",
   "address": "0",
   "type": "switch",
   "format": "u16",
   "on_value": "0x00a5", // ON
   "off_value": "0x005a" // OFF
}
            </code>
            </pre>

            <p>Now the driver will automatically convert the specified values to the switch position when reading, and write the specified values when the switch position changes.</p>

            <h1 id="TechnicalDetails">Technical Details</h1>
            <table border="1" class="wikitable" style="text-align:left">
               <tbody>
                  <tr>
                     <th colspan="2"><b>General</b></th>
                  </tr>
                  <tr>
                     <td style="width: 300px">CPU</td>
                     <td>ARM Cortex A7 4 core 1.2 GHz</td>
                  </tr>
                  <tr>
                     <td>RAM</td>
                     <td>DDR3 RAM 2 GB</td>
                  </tr>
                  <tr>
                     <td>FLASH</td>
                     <td>64 GB TLC BiCS5</td>
                  </tr>
                  <tr>
                     <th colspan="2"><b>Dimensions</b></th>
                  </tr>
                  <tr>
                     <td>Mounting</td>
                     <td>DIN rail</td>
                  </tr>
                  <tr>
                     <td>Width, DIN-units</td>
                     <td>6</td>
                  </tr>
                  <tr>
                     <td>Sizes (H x W х D)</td>
                     <td>106 x 90 x 58 mm</td>
                  </tr>
                  <tr>
                     <td>Weight (with box)</td>
                     <td>235 g</td>
                  </tr>
                  <tr>
                     <th colspan="2">Operating conditions</th>
                  </tr>
                  <tr>
                     <td>Air temperature</td>
                     <td>0 ... +75 °C</td>
                  </tr>
                  <tr>
                     <td>Humidity</td>
                     <td>Up to 92%, without condensation of moisture</td>
                  </tr>
                  <tr>
                     <td>Warranty period</td>
                     <td>2 years</td>
                  </tr>
                  <tr>
                     <td>Service life</td>
                     <td>5 years</td>
                  </tr>
                  <tr>
                     <th colspan="2"><b>Interfaces</b></th>
                  </tr>
                  <tr>
                     <td>KNX</td>
                     <td>1 — only for ZMEEWB7-ZW-ZB-KNX</td>
                  <tr>
                     <td>RS-485</td>
                     <td>2</td>
                  </tr>
                  <tr>
                     <td>CAN</td>
                     <td>1 — multiplexed with one of RS-485</td>
                  </tr>
                  <tr>
                     <td>microSD slot up to 25 MB/s</td>
                     <td>1</td>
                  </tr>
                  <tr>
                     <td>Wx ports: 1-Wire interface/digital input</td>
                     <td>2</td>
                  </tr>
                  <tr>
                     <td>Ax ports: digital/analog input and output "open collector"</td>
                     <td>3</td>
                  </tr>
                  <tr>
                     <td>Port D1: digital input/output "open collector"</td>
                     <td>1</td>
                  </tr>
                  <tr>
                     <th colspan="2"><b>Communications</b></th>
                  </tr>
                  <tr>
                     <td>Ethernet 10/100</td>
                     <td>2 (the first of the ports with Passive PoE)</td>
                  </tr>
                  <tr>
                     <td>USB Host (USB-A)</td>
                     <td>1</td>
                  </tr>
                  <tr>
                     <td>Debug Network (USB-C)</td>
                     <td>USB network card for quick configuration of the controller. Important: When the port is connected to the computer, USB 1 is disconnected</td>
                  </tr>
                  <tr>
                     <td>Wi-Fi 802.11n</td>
                     <td>1 AP, client</td>
                  </tr>
                  <tr>
                     <td>Bluetooth 4.0</td>
                     <td>1</td>
                  </tr>
                  <tr>
                     <td>Z-Wave</td>
                     <td>700 Series Chip 868.42 MHz</td>
                  </tr>
                  <tr>
                     <td>Zigbee</td>
                     <td>MG21 Series Chip 2.4 GHz (can be converted to BLE or Thread, Matter ready)</td>
                  </tr>
                  <tr>
                     <td>SIM-cards</td>
                     <td>2 x SIM, one is online at the same time</td>
                  </tr>
                  <tr>
                     <th colspan="2">Power</th>
                  </tr>
                  <tr>
                     <td>Voltage</td>
                     <td>9 - 48 V DC</td>
                  </tr>
                  <tr>
                     <td>Power consumption</td>
                     <td>3 W</td>
                  </tr>
                  <tr>
                     <td>Power scheme</td>
                     <td>from a high voltage input</td>
                  </tr>
                  <tr>
                     <td>Power inputs</td>
                     <td>2 on the terminals, 1 Passive PoE on the first Ethernet port</td>
                  </tr>
                  <tr>
                     <th colspan="2"><b>Outputs for powering external devices</b></th>
                  </tr>
                  <tr>
                     <td>Vout</td>
                     <td>The power supply voltage of the controller is applied to the terminals, but with current limitation, program shutdown and state preservation when the controller is rebooted.</td>
                  </tr>
                  <tr>
                     <td>5Vout</td>
                     <td>5 V — with current limitation and software shutdown</td>
                  </tr>
                  <tr>
                     <th colspan="2"><b>Modules</b></th>
                  </tr>
                  <tr>
                     <td>Slots for internal expansion modules</td>
                     <td>3 with terminals, 1 without terminals (two are occupied with Z-Wave and Zigbee modules, and one with KNX module)</td>
                  </tr>
                  <tr>
                     <td>Other connectors</td>
                     <td>For external Input/Output modules, for backup power module</td>
                  </tr>
               </tbody>
            </table>
         </div>
      </div>
   </body>
</html>
